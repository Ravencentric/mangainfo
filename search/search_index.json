{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#table-of-contents","title":"Table Of Contents","text":"<ul> <li>About</li> <li>Installation</li> <li>Usage</li> <li>License</li> </ul>"},{"location":"#about","title":"About","text":"<p><code>mangainfo</code> is both a library and CLI tool to generate mediainfo for manga archives.</p>"},{"location":"#installation","title":"Installation","text":"<p><code>mangainfo</code> is both a library and CLI tool to generate mediainfo for manga archives. This relies on archivefile for reading the archives and pymediainfo for generating the mediainfo.</p> <pre><code>pip install mangainfo\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>As a library:</p> <pre><code>from mangainfo import MangaParser\n\narchive = \"~/Blue Box (Digital) (1r0n)/Blue Box v06 (2023) (Digital) (1r0n).cbz\"\n\nmanga = MangaParser(archive).partial_scan()\n\nfor page in manga.pages:\n    print(page.resolution)\n</code></pre> <p>As a CLI:</p> <pre><code>\u276f mangainfo --help\nusage: mangainfo [-h] [--full] path\n\nGenerate mediainfo-esque text from a manga archive.\n\npositional arguments:\n  path        Path to a manga archive.\n\noptions:\n  -h, --help  show this help message and exit\n  --full      Scan every page. More accurate data but far slower.\n</code></pre> <p>Refer to the API reference for more details.</p>"},{"location":"#license","title":"License","text":"<p>Distributed under the Unlicense License. See UNLICENSE for more information.</p>"},{"location":"api-reference/mangaparser/","title":"MangaParser","text":""},{"location":"api-reference/mangaparser/#mangainfo.MangaParser","title":"MangaParser","text":"<pre><code>MangaParser(volume: Path | str)\n</code></pre> <p>Initialize the MangaParser.</p> <p>Parameters:</p> Name Type Description Default <code>volume</code> <code>Path | str</code> <p>The path to the manga volume file or directory.</p> required Source code in <code>src/mangainfo/_core.py</code> <pre><code>def __init__(self, volume: Path | str) -&gt; None:\n    \"\"\"\n    Initialize the MangaParser.\n\n    Parameters\n    ----------\n    volume : Path | str\n        The path to the manga volume file or directory.\n    \"\"\"\n    self.volume = Path(volume).expanduser().resolve()\n</code></pre>"},{"location":"api-reference/mangaparser/#mangainfo.MangaParser.full_scan","title":"full_scan","text":"<pre><code>full_scan() -&gt; MangaInfo\n</code></pre> <p>Perform a full scan of the manga volume.</p> <p>Returns:</p> Type Description <code>MangaInfo</code> <p>Information about the manga volume including all parsed pages.</p> Notes <p>Depending on your hardware, this may be slow (~1s) as this will parse every single page in the manga archive.</p> Source code in <code>src/mangainfo/_core.py</code> <pre><code>def full_scan(self) -&gt; MangaInfo:\n    \"\"\"\n    Perform a full scan of the manga volume.\n\n    Returns\n    -------\n    MangaInfo\n        Information about the manga volume including all parsed pages.\n\n    Notes\n    -----\n    Depending on your hardware, this may be slow (~1s) as this will parse every single page in the manga archive.\n    \"\"\"\n    return MangaInfo(pages=parse_all_pages(self.volume), **parse_volume(self.volume))  # type: ignore\n</code></pre>"},{"location":"api-reference/mangaparser/#mangainfo.MangaParser.partial_scan","title":"partial_scan","text":"<pre><code>partial_scan() -&gt; MangaInfo\n</code></pre> <p>Perform a partial scan of the manga volume, extracting and parsing only the smallest, median, and largest pages.</p> <p>Returns:</p> Type Description <code>MangaInfo</code> <p>Information about the manga volume including the parsed smallest, median, and largest pages.</p> Notes <p>This is roughly 3x faster than <code>full_scan()</code>. Some methods may return less accurate data because they don't have enough pages to work with.</p> Source code in <code>src/mangainfo/_core.py</code> <pre><code>def partial_scan(self) -&gt; MangaInfo:\n    \"\"\"\n    Perform a partial scan of the manga volume, extracting and parsing\n    only the smallest, median, and largest pages.\n\n    Returns\n    -------\n    MangaInfo\n        Information about the manga volume including the parsed smallest,\n        median, and largest pages.\n\n    Notes\n    -----\n    This is roughly 3x faster than `full_scan()`.\n    Some methods may return less accurate data because they don't have enough pages to work with.\n    \"\"\"\n    from statistics import median_low\n    from tempfile import TemporaryDirectory\n    from uuid import uuid4\n\n    from archivefile import ArchiveFile\n\n    volume = parse_volume(self.volume)\n\n    with ArchiveFile(self.volume) as archive:\n        members = {\n            member.size: member.name\n            for member in archive.get_members()\n            if member.name.lower().endswith((\".png\", \".jpg\", \".jpeg\"))\n        }\n        smallest_file = members[min(members)]\n        median_file = members[median_low(members)]\n        largest_file = members[max(members)]\n\n        tmp_dir = TemporaryDirectory()\n        tmp_path = Path(tmp_dir.name).resolve() / uuid4().hex[:10]\n\n        archive.extractall(destination=tmp_path, members=(smallest_file, median_file, largest_file))\n\n        pages = (\n            parse_page(tmp_path / smallest_file, parent=tmp_path),\n            parse_page(tmp_path / median_file, parent=tmp_path),\n            parse_page(tmp_path / largest_file, parent=tmp_path),\n        )\n\n        try:\n            tmp_dir.cleanup()\n        except:  # noqa: E722; # pragma: no cover\n            pass\n\n        return MangaInfo(pages=pages, **volume)  # type: ignore\n</code></pre>"},{"location":"api-reference/models/","title":"Models","text":""},{"location":"api-reference/models/#mangainfo._models.Resolution","title":"Resolution","text":"<p>             Bases: <code>BaseModel</code></p> <p>Resolution of the image in pixels</p>"},{"location":"api-reference/models/#mangainfo._models.Resolution.as_str","title":"as_str","text":"<pre><code>as_str() -&gt; str\n</code></pre> <p>Return a human-readable representation of the resolution in the format: <code>{width}x{height}</code></p> Source code in <code>src/mangainfo/_models.py</code> <pre><code>def as_str(self) -&gt; str:\n    \"\"\"Return a human-readable representation of the resolution in the format: `{width}x{height}`\"\"\"\n    return f\"{self.width}x{self.height}\"\n</code></pre>"},{"location":"api-reference/models/#mangainfo._models.Resolution.as_tuple","title":"as_tuple","text":"<pre><code>as_tuple() -&gt; tuple[int, int]\n</code></pre> <p>Return the resolution as a tuple of integers: <code>(width, height)</code></p> Source code in <code>src/mangainfo/_models.py</code> <pre><code>def as_tuple(self) -&gt; tuple[int, int]:\n    \"\"\"Return the resolution as a tuple of integers: `(width, height)`\"\"\"\n    return (self.width, self.height)\n</code></pre>"},{"location":"api-reference/models/#mangainfo._models.Resolution.is_landscape","title":"is_landscape","text":"<pre><code>is_landscape() -&gt; bool\n</code></pre> <p>Check if the resolution is landscape.</p> Source code in <code>src/mangainfo/_models.py</code> <pre><code>def is_landscape(self) -&gt; bool:\n    \"\"\"Check if the resolution is landscape.\"\"\"\n    return self.width &gt; self.height\n</code></pre>"},{"location":"api-reference/models/#mangainfo._models.Resolution.is_portrait","title":"is_portrait","text":"<pre><code>is_portrait() -&gt; bool\n</code></pre> <p>Check if the resolution is portrait.</p> Source code in <code>src/mangainfo/_models.py</code> <pre><code>def is_portrait(self) -&gt; bool:\n    \"\"\"Check if the resolution is portrait.\"\"\"\n    return self.height &gt; self.width\n</code></pre>"},{"location":"api-reference/models/#mangainfo._models.PageInfo","title":"PageInfo","text":"<p>             Bases: <code>BaseModel</code></p> <p>Media information about the page, as returned by pymediainfo.MediaInfo.</p>"},{"location":"api-reference/models/#mangainfo._models.PageInfo.bit_depth","title":"bit_depth  <code>instance-attribute</code>","text":"<pre><code>bit_depth: int\n</code></pre> <p>Bit depth.</p>"},{"location":"api-reference/models/#mangainfo._models.PageInfo.chroma_subsampling","title":"chroma_subsampling  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>chroma_subsampling: str | None = None\n</code></pre> <p>Chroma subsampling.</p>"},{"location":"api-reference/models/#mangainfo._models.PageInfo.color_space","title":"color_space  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>color_space: str | None = None\n</code></pre> <p>Color space of the page.</p>"},{"location":"api-reference/models/#mangainfo._models.PageInfo.compression","title":"compression  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>compression: str | None = None\n</code></pre> <p>Compression method used on the page.</p>"},{"location":"api-reference/models/#mangainfo._models.PageInfo.compression_mode","title":"compression_mode  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>compression_mode: str | None = None\n</code></pre> <p>Type of compression used on the page.</p>"},{"location":"api-reference/models/#mangainfo._models.PageInfo.extension","title":"extension  <code>instance-attribute</code>","text":"<pre><code>extension: str\n</code></pre> <p>Extension of the page.</p>"},{"location":"api-reference/models/#mangainfo._models.PageInfo.format","title":"format  <code>instance-attribute</code>","text":"<pre><code>format: str\n</code></pre> <p>Format of the page.</p>"},{"location":"api-reference/models/#mangainfo._models.PageInfo.format_info","title":"format_info  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>format_info: str | None = None\n</code></pre> <p>Additional information about the format.</p>"},{"location":"api-reference/models/#mangainfo._models.PageInfo.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: Path\n</code></pre> <p>Name of the page.</p>"},{"location":"api-reference/models/#mangainfo._models.PageInfo.resolution","title":"resolution  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>resolution: Resolution = Resolution()\n</code></pre> <p>Resolution of the page.</p>"},{"location":"api-reference/models/#mangainfo._models.PageInfo.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>size: ByteSize = ByteSize(0)\n</code></pre> <p>Size of the page</p>"},{"location":"api-reference/models/#mangainfo._models.MangaInfo","title":"MangaInfo","text":"<p>             Bases: <code>BaseModel</code></p> <p>Media information about the manga archive, as returned by pymediainfo.MediaInfo.</p>"},{"location":"api-reference/models/#mangainfo._models.MangaInfo.extension","title":"extension  <code>instance-attribute</code>","text":"<pre><code>extension: str\n</code></pre> <p>Extension of the volume archive.</p>"},{"location":"api-reference/models/#mangainfo._models.MangaInfo.format","title":"format  <code>instance-attribute</code>","text":"<pre><code>format: str\n</code></pre> <p>Format of the volume archive.</p>"},{"location":"api-reference/models/#mangainfo._models.MangaInfo.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: Path\n</code></pre> <p>Name of the volume archive.</p>"},{"location":"api-reference/models/#mangainfo._models.MangaInfo.page_count","title":"page_count  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>page_count: int = 0\n</code></pre> <p>Number of pages in the volume archive.</p>"},{"location":"api-reference/models/#mangainfo._models.MangaInfo.pages","title":"pages  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pages: tuple[PageInfo, ...] = tuple()\n</code></pre> <p>A tuple of <code>PageInfo</code> objects representing the pages inside the volume archive. If <code>partial_scan()</code> was called, then this  will only have a maximum of 3 pages: smallest, median, and largest.  If <code>full_scan()</code> was called, then this will have have a <code>PageInfo</code> object for every page in the archive.</p>"},{"location":"api-reference/models/#mangainfo._models.MangaInfo.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>size: ByteSize = ByteSize(0)\n</code></pre> <p>Size of the volume archive.</p>"},{"location":"api-reference/models/#mangainfo._models.MangaInfo.average_page_size","title":"average_page_size","text":"<pre><code>average_page_size() -&gt; ByteSize\n</code></pre> <p>Calculate the average page size of the volume archive.</p> <p>Returns:</p> Type Description <code>ByteSize</code> <p>The average page size of the volume archive.</p> Source code in <code>src/mangainfo/_models.py</code> <pre><code>def average_page_size(self) -&gt; ByteSize:\n    \"\"\"\n    Calculate the average page size of the volume archive.\n\n    Returns\n    -------\n    ByteSize\n        The average page size of the volume archive.\n    \"\"\"\n\n    data = [page.size for page in self.pages]\n    return ByteSize(sum(data) / len(data))\n</code></pre>"},{"location":"api-reference/models/#mangainfo._models.MangaInfo.largest_page","title":"largest_page","text":"<pre><code>largest_page() -&gt; PageInfo\n</code></pre> <p>Find the largest page in the archive by size.</p> <p>Returns:</p> Type Description <code>PageInfo</code> <p>The largest page in the archive.</p> Source code in <code>src/mangainfo/_models.py</code> <pre><code>def largest_page(self) -&gt; PageInfo:\n    \"\"\"\n    Find the largest page in the archive by size.\n\n    Returns\n    -------\n    PageInfo\n        The largest page in the archive.\n    \"\"\"\n    return max(self.pages, key=lambda page: page.size)\n</code></pre>"},{"location":"api-reference/models/#mangainfo._models.MangaInfo.mediainfo","title":"mediainfo","text":"<pre><code>mediainfo() -&gt; str\n</code></pre> <p>Generate a mediainfo-esque string describing the archive, including information about the smallest, median, and largest pages in the archive.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string formatted similarly to mediainfo output, providing information about the archive.</p> Source code in <code>src/mangainfo/_models.py</code> <pre><code>def mediainfo(self) -&gt; str:\n    \"\"\"\n    Generate a mediainfo-esque string describing the archive,\n    including information about the smallest, median, and largest pages in the archive.\n\n    Returns\n    -------\n    str\n        A string formatted similarly to mediainfo output,\n        providing information about the archive.\n    \"\"\"\n    volume_info = \"Volume\\n\"\n    data = self.model_dump(exclude_defaults=True, exclude_none=True, exclude_unset=True)\n    pages = data.pop(\"pages\")\n\n    for key, value in data.items():\n        if key == \"size\":\n            value = ByteSize(value).human_readable(separator=\" \")\n\n        key = key.replace(\"_\", \" \").title()\n        volume_info += f\"{key:&lt;20}: {value}\\n\"\n\n    volume_info += f\"{'Average Page Size':&lt;20}: {self.average_page_size().human_readable(separator=' ')}\\n\"\n\n    if len(pages) &gt; 3:\n        page_info = \"\"\n        volume_info += f\"{'Unique Resolutions':&lt;20}: {', '.join(f'{resolution}: {count}' for resolution, count in self.unique_resolutions())}\"\n        for index, page in enumerate((self.smallest_page(), self.median_page(), self.largest_page()), start=1):\n            page_info += f\"\\n\\nPage #{index}\\n\"\n            for key, value in page.model_dump(exclude_defaults=True, exclude_none=True, exclude_unset=True).items():\n                if key == \"size\":\n                    value = ByteSize(value).human_readable(separator=\" \")\n                if key == \"resolution\":\n                    value = Resolution(width=value[\"width\"], height=value[\"height\"]).as_str()\n\n                key = key.replace(\"_\", \" \").title()\n                page_info += f\"{key:&lt;20}: {value}\\n\"\n\n    elif len(pages) &gt;= 1 and len(pages) &lt;= 3:\n        page_info = \"\"\n        for index, page in enumerate(self.pages, start=1):\n            page_info += f\"\\n\\nPage #{index}\\n\"\n            for key, value in page.model_dump(exclude_defaults=True, exclude_none=True, exclude_unset=True).items():\n                if key == \"size\":\n                    value = ByteSize(value).human_readable(separator=\" \")\n                if key == \"resolution\":\n                    value = Resolution(width=value[\"width\"], height=value[\"height\"]).as_str()\n\n                key = key.replace(\"_\", \" \").title()\n                page_info += f\"{key:&lt;20}: {value}\\n\"\n\n    else:  # pragma: no cover\n        page_info = \"\"\n\n    return f\"{volume_info}{page_info}\".strip()\n</code></pre>"},{"location":"api-reference/models/#mangainfo._models.MangaInfo.median_page","title":"median_page","text":"<pre><code>median_page() -&gt; PageInfo\n</code></pre> <p>Find the median page in the archive by size.</p> <p>Returns:</p> Type Description <code>PageInfo</code> <p>The median page in the archive.</p> Source code in <code>src/mangainfo/_models.py</code> <pre><code>def median_page(self) -&gt; PageInfo:\n    \"\"\"\n    Find the median page in the archive by size.\n\n    Returns\n    -------\n    PageInfo\n        The median page in the archive.\n    \"\"\"\n    from statistics import median_low\n\n    data = {page.size: page for page in self.pages}\n    return data[median_low(data.keys())]\n</code></pre>"},{"location":"api-reference/models/#mangainfo._models.MangaInfo.smallest_page","title":"smallest_page","text":"<pre><code>smallest_page() -&gt; PageInfo\n</code></pre> <p>Find the smallest page in the archive by size.</p> <p>Returns:</p> Type Description <code>PageInfo</code> <p>The smallest page in the archive.</p> Source code in <code>src/mangainfo/_models.py</code> <pre><code>def smallest_page(self) -&gt; PageInfo:\n    \"\"\"\n    Find the smallest page in the archive by size.\n\n    Returns\n    -------\n    PageInfo\n        The smallest page in the archive.\n    \"\"\"\n    return min(self.pages, key=lambda page: page.size)\n</code></pre>"},{"location":"api-reference/models/#mangainfo._models.MangaInfo.unique_resolutions","title":"unique_resolutions","text":"<pre><code>unique_resolutions() -&gt; tuple[tuple[Resolution, int], ...]\n</code></pre> <p>Count the occurrences of unique resolutions in the archive.</p> <p>Returns:</p> Type Description <code>tuple[tuple[Resolution, int], ...]</code> <p>A tuple of tuples containing unique resolutions and their counts, sorted by frequency in descending order.</p> Source code in <code>src/mangainfo/_models.py</code> <pre><code>def unique_resolutions(self) -&gt; tuple[tuple[Resolution, int], ...]:\n    \"\"\"\n    Count the occurrences of unique resolutions in the archive.\n\n    Returns\n    -------\n    tuple[tuple[Resolution, int], ...]\n        A tuple of tuples containing unique resolutions and their counts,\n        sorted by frequency in descending order.\n    \"\"\"\n    from collections import Counter\n\n    return tuple(Counter(page.resolution for page in self.pages).most_common())\n</code></pre>"}]}